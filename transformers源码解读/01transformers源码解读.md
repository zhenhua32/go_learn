[TOC]

# 简介

transformers 提供了众多预训练的模型, 用于文本, 视觉和音频方面. 而且它本身是建立众多 AI 框架之上的, 包括三个热门框架,
JAX, PyTorch 和 TensorFlow.

我本身没接触过 JAX, 不会关注这一部分. 目前的计划是从通过的基础功能讲起, 先专注于 TensorFlow, 然后介绍 PyTorch.

代码相关的注释都会记录在自己 fork 的仓库上, [transformers](https://github.com/zhenhua32/transformers).

那么, 从今天开始, 一起走进科学.

# 一览众山小

先来看看 `__init__.py` 中有些什么.

文件过长, 洋洋洒洒几千行, 主要就是构建了一个 `_import_structure` 字典. 这里面就是所有能够导入的模型的名称.

```python
_import_structure = {
    "benchmark": [],
    "commands": [],
    "configuration_utils": ["PretrainedConfig"],
    "convert_graph_to_onnx": [],
    ...
}
```

然后检查了下模块是否存在, 通过检测不同的 AI 框架或其他依赖, 不断修改 `_import_structure` 的内容.

如果特定模块不存在, 就会从 `.utils` 中导入一系列的 `dummy_` 开头的假模块.

```python
from .utils import dummy_sentencepiece_objects

if is_sentencepiece_available():
    ...
else:
    from .utils import dummy_sentencepiece_objects

    _import_structure["utils.dummy_sentencepiece_objects"] = [
        name for name in dir(dummy_sentencepiece_objects) if not name.startswith("_")
    ]
```

部分检查模块是否存在的代码也挺简单的, 使用了标准库中 `importlib` 的功能.

```python
def is_sentencepiece_available():
    return importlib.util.find_spec("sentencepiece") is not None
```

## 如何构建一个假的模块

```python
from ..utils import DummyObject, requires_backends

class AlbertTokenizer(metaclass=DummyObject):
    _backends = ["sentencepiece"]

    def __init__(self, *args, **kwargs):
        requires_backends(self, ["sentencepiece"])
```

构建一个假的模块的方式是简单粗暴的, 直接把模块下的类重新定义一下, 主要就是定义一个类变量 `_backends` 描述依赖, 定义 `__init__` 方法,
等你实际运行时告诉你需要什么依赖.

先来看看元类 `DummyObject`:

```python
class DummyObject(type):
    """
    Metaclass for the dummy objects. Any class inheriting from it will return the ImportError generated by
    `requires_backend` each time a user tries to access any method of that class.
    """

    def __getattr__(cls, key):
        if key.startswith("_"):
            return super().__getattr__(cls, key)
        requires_backends(cls, cls._backends)
```

只实现了一个方法, 就是当尝试访问任何非 `_` 开头的属性时都调用 `requires_backends` 函数. 那么具体来看看 `requires_backends`:

```python
def requires_backends(obj, backends):
    if not isinstance(backends, (list, tuple)):
        backends = [backends]

    name = obj.__name__ if hasattr(obj, "__name__") else obj.__class__.__name__
    checks = (BACKENDS_MAPPING[backend] for backend in backends)
    failed = [msg.format(name) for available, msg in checks if not available()]
    if failed:
        raise ImportError("".join(failed))
```

checks 中返回的是一个元组, 每个元组里又是一个小元组, 里面就一个检查是否可用的方法和错误信息, 当不可用的时候就友好的提示你需要什么以及该怎么做.
简单点的依赖就告诉你怎么用 `pip` 安装, 复杂点的就告诉你一个官方安装文档的链接.

## 检查 TYPE_CHECKING 和延迟加载模块

跳过一大堆的可用模块检查之后, 就会来到 `TYPE_CHECKING` 检查了.

```python
if TYPE_CHECKING:
    # 会实际导入所有模块
    ...
else:
    import sys

    sys.modules[__name__] = _LazyModule(
        __name__,
        globals()["__file__"],
        _import_structure,
        module_spec=__spec__,
        extra_objects={"__version__": __version__},
    )
```

`TYPE_CHECKING` 这个变量挺有意思的, 这个变量会被第三方的代码检查器当成是 `True`, 但在 runtime 时是 `False`.
配合这边的代码来说, 就是在你写代码时, 会实际导入所有模块, 用于类型检查或者代码提示之类的功能.
而当实际运行代码后, 就会使用 `_LazyModule` 延迟加载模块.

一直对代码的延迟加载挺好奇的, 这次就来一探究竟吧.

`sys.modules` 是一个字典, 用于映射已经加载的模块, 所以直接修改了当前模块, 也就是 `__name__` 对应的名字.

```python
class _LazyModule(ModuleType):
    """
    Module class that surfaces all objects but only performs associated imports when the objects are requested.
    """

    # Very heavily inspired by optuna.integration._IntegrationModule
    # https://github.com/optuna/optuna/blob/master/optuna/integration/__init__.py
    def __init__(self, name, module_file, import_structure, module_spec=None, extra_objects=None):
        super().__init__(name)
        self._modules = set(import_structure.keys())
        self._class_to_module = {}
        for key, values in import_structure.items():
            for value in values:
                self._class_to_module[value] = key
        # Needed for autocompletion in an IDE
        self.__all__ = list(import_structure.keys()) + list(chain(*import_structure.values()))
        self.__file__ = module_file
        self.__spec__ = module_spec
        self.__path__ = [os.path.dirname(module_file)]
        self._objects = {} if extra_objects is None else extra_objects
        self._name = name
        self._import_structure = import_structure

    # Needed for autocompletion in an IDE
    def __dir__(self):
        result = super().__dir__()
        # The elements of self.__all__ that are submodules may or may not be in the dir already, depending on whether
        # they have been accessed or not. So we only add the elements of self.__all__ that are not already in the dir.
        for attr in self.__all__:
            if attr not in result:
                result.append(attr)
        return result

    def __getattr__(self, name: str) -> Any:
        if name in self._objects:
            return self._objects[name]
        if name in self._modules:
            value = self._get_module(name)
        elif name in self._class_to_module.keys():
            module = self._get_module(self._class_to_module[name])
            value = getattr(module, name)
        else:
            raise AttributeError(f"module {self.__name__} has no attribute {name}")

        setattr(self, name, value)
        return value

    def _get_module(self, module_name: str):
        try:
            return importlib.import_module("." + module_name, self.__name__)
        except Exception as e:
            raise RuntimeError(
                f"Failed to import {self.__name__}.{module_name} because of the following error (look up to see its traceback):\n{e}"
            ) from e

    def __reduce__(self):
        return (self.__class__, (self._name, self.__file__, self._import_structure))
```

`sys.modules` 的值的类型是 `module`, 而 `module` 的父类是 `type`.
`ModuleType` 是这样定义的, `ModuleType = type(sys)`.

实际上, `module` 类型就是使用 `import` 语句后获取的结果. 所以应该只要实现相同的方法就行了.

有部分代码是为了 IDE 的自动完成而编写的, 先来看看 `__getattr__` 是如何查找的.

分别从 `_objects`, `_modules`, `_class_to_module` 寻找, 如果找到了, 会通过 `setattr(self, name, value)` 直接更新属性.
更新属性后会保存在 `__dict__` 中, 下次就不用再重新导入模块了.

在寻找的过程中, 使用了 `_get_module`, 这个主要就是 `import_module` 函数导入模块了.

`importlib.import_module("." + module_name, self.__name__)` 的意思就是从 `self.__name__` 中导入 `module_name`.

## 小结

看完了这些, 最后就剩下一个 AI 框架判断了, 就是说这三个框架必须要有一个才能使用 transformers.

```python
if not is_tf_available() and not is_torch_available() and not is_flax_available():
```
